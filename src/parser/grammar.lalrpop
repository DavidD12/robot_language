
use crate::model::*;
use super::*;
use line_col::LineColLookup;

grammar(lookup: &LineColLookup<'input>, model: &mut Model);

match {
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _
}

//------------------------- Model -------------------------

pub Model: () = <types: Type> <skillsets: Skillset*> => {
    for x in types {
        model.add_type(x);
    }
    for x in skillsets {
        model.add_skillset(x);
    }
};

//------------------------- Type -------------------------

Type: Vec<RlType> = {
    <v: TypeSingle*> => v,
    <v: TypeBlock> => v,
};

TypeSingle: RlType = "type" <x:Identifier> => {
    RlType::empty(x.name, Some(x.position))
};

TypeBlock: Vec<RlType> = "type" "{" <l:(<Identifier>)*> "}" => {
    let mut v = Vec::new();
    for x in l {
        v.push(RlType::empty(x.name, Some(x.position)))
    }
    v
};

TypeRef: Reference<TypeId> = <x:Identifier> => {
    Reference::Unresolved(x.name, Some(x.position))
};

//------------------------- Skillset -------------------------

Skillset: Skillset = "skillset" <x:Identifier> "{" <data:Data> <resources:Resource> <events:Event> <skills:Skill> "}" => {
    let mut skillset = Skillset::empty(x.name, Some(x.position));
    for x in data {
        skillset.add_data(x);
    }
    for x in resources {
        skillset.add_resource(x);
    }
    for x in events {
        skillset.add_event(x);
    }
    for x in skills {
        skillset.add_skill(x);
    }
    skillset
};

//------------------------- Data -------------------------

Data: Vec<Data> = {
    <v: DataSingle*> => v,
    <v: DataBlock> => v,
};

DataSingle: Data = "data" <d:DataDef> => d;
DataBlock: Vec<Data> = "data" "{" <l:DataDef*> "}" => l;

DataDef: Data = <x:Identifier> ":" <t:TypeRef> => Data::empty(x.name, t, Some(x.position));

//------------------------- Resource -------------------------

Resource: Vec<Resource> = {
    <v: ResourceSingle*> => v,
    <v: ResourceBlock> => v,
};

ResourceSingle: Resource = "resource" <x:ResourceDef> => x;
ResourceBlock: Vec<Resource> = "resource" "{" <l:ResourceDef*> "}" => l;

ResourceDef: Resource = <x:Identifier> "{" <s:StateDef> <i:InitialDef> <t:Transitions> "}" => {
    let mut resource = Resource::empty(x.name, Some(x.position));
    for x in s {
        resource.add_state(x);
    }
    resource.set_initial(i);
    resource.set_transitions(t);
    resource
};

ResourceRef: Reference<ResourceId> = <x:Identifier> => Reference::Unresolved(x.name, Some(x.position));

//------------------------- State -------------------------

StateDef: Vec<State> = "state" "{" <l:Identifier*> "}" => {
    let mut v = Vec::new();
    for x in l {
        v.push(State::empty(x.name, Some(x.position)));
    }
    v
};

InitialDef: Reference<StateId> = "initial" <s:StateRef> => s;

StateRef: Reference<StateId> = <x:Identifier> => Reference::Unresolved(x.name, Some(x.position));

//------------------------- Transition -------------------------

Transitions: Transitions = {
    "transition" "all" => Transitions::All,
    "transition" "{" <l:Transition*> "}" => Transitions::List(l),
};

Transition: Transition = <s:StateRef> "->" <d:StateRef> => Transition::new(s, d);

//------------------------- Event -------------------------

Event: Vec<Event> = {
    <v: EventSingle*> => v,
    <v: EventBlock> => v,
};

EventSingle: Event = "event" <e:EventDef> => e;
EventBlock: Vec<Event> = "event" "{" <l:EventDef*> "}" => l;

EventDef: Event = <x:Identifier> "{" <g:Guard?> <l:Effects> "}" => Event::empty(x.name, g, l, Some(x.position));

Guard: Expr = "guard" <e:Expr> => e;

//------------------------- Skill -------------------------

Skill: Vec<Skill> = {
    <v: SkillSingle*> => v,
    <v: SkillBlock> => v,
};

SkillSingle: Skill = "skill" <s:SkillDef> => s;
SkillBlock: Vec<Skill> = "skill" "{" <l:SkillDef*> "}" => l;

SkillDef: Skill = <x:Identifier> "{" <i:Input> <o:Output> <p:Precondition> <s:Start?> "}" => {
    let mut skill = Skill::empty(x.name, Some(x.position));
    for x in i {
        skill.add_input(x);
    }
    for x in o {
        skill.add_output(x);
    }
    for x in p {
        skill.add_precondition(x);
    }
    if let Some(e) = s {
        skill.set_start(e);
    }
    //
    skill
};

//------------------------- Input -------------------------

Input: Vec<Input> = {
    <v: InputSingle*> => v,
    <v: InputBlock> => v,
};

InputSingle: Input = "input" <p:InputDef> => p;
InputBlock: Vec<Input> = "input" "{" <l:InputDef*> "}" => l;

InputDef: Input = <n:Identifier> ":" <t:TypeRef> => Input::empty(n.name, t, Some(n.position));

//------------------------- Output -------------------------

Output: Vec<Output> = {
    <v: OutputSingle*> => v,
    <v: OutputBlock> => v,
};

OutputSingle: Output = "output" <p:OutputDef> => p;
OutputBlock: Vec<Output> = "output" "{" <l:OutputDef*> "}" => l;

OutputDef: Output = <n:Identifier> ":" <t:TypeRef> => Output::empty(n.name, t, Some(n.position));

//------------------------- Precondition -------------------------

Precondition: Vec<Precondition> = {
    <v: PreconditionSingle*> => v,
    <v: PreconditionBlock> => v,
};

PreconditionSingle: Precondition = "precondition" <p:PreconditionDef> => p;
PreconditionBlock: Vec<Precondition> = "precondition" "{" <l:PreconditionDef*> "}" => l;

PreconditionDef: Precondition = <n:Identifier> ":" <e:Expr> => Precondition::new(n.name, e, Some(n.position));

//------------------------- Start -------------------------

Start: Vec<Effect> = {
    <v: StartSingle> => v,
    <v: StartBlock> => v,
};

StartSingle: Vec<Effect> = "start"  <e:Effect> => vec![e];
StartBlock: Vec<Effect> = "start" "{" <l:Effect*> "}" => l;

//------------------------- Effect -------------------------

Effects: Vec<Effect> = {
    <v: EffectSingle> => v,
    <v: EffectBlock> => v
};

EffectSingle: Vec<Effect> = "effect" <e:Effect> => vec![e];
EffectBlock: Vec<Effect> = "effect" "{" <l:Effect*> "}" => l;

Effect: Effect = <r:ResourceRef> "->" <s:StateRef> => Effect::new(r, s);

//------------------------- Expr -------------------------

Expr: Expr = ImpliesExpr;
ImpliesExpr: Expr = {
    <left:ImpliesExpr> "=>" <right:OrExpr> => {
        Expr::Implies(Box::new(left), Box::new(right))
    },
    OrExpr,
};
OrExpr: Expr = {
    <left:OrExpr> "or" <right:AndExpr> => {
        Expr::Or(Box::new(left), Box::new(right))
    },
    AndExpr,
};
AndExpr: Expr = {
    <left:AndExpr> "and" <right:NotExpr> => {
        Expr::And(Box::new(left), Box::new(right))
    },
    NotExpr,
};
NotExpr: Expr = {
    "not" <e: NotExpr> => {
        Expr::Not(Box::new(e))
    },
    Term,
};

Term: Expr = {
    "false" => Expr::False,
    "true" => Expr::True,
    <r:ResourceRef> "==" <s:StateRef> => Expr::ResourceEq(r, s),
    <r:ResourceRef> "!=" <s:StateRef> => Expr::ResourceNe(r, s),
    "(" <Expr> ")",
};

//------------------------- Lexer -------------------------

Identifier: Identifier = <l:@L> <s:r"[a-zA-Z_][a-zA-Z_0-9]*"> <r:@R> => {
    Identifier::new(lookup, s, l)
};