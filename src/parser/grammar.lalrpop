
use crate::model::*;
use super::*;
use line_col::LineColLookup;

grammar(lookup: &LineColLookup<'input>, model: &mut Model);

match {
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _
}

//------------------------- Model -------------------------

pub Model: () = <types: Type> <skillsets: Skillset*> => {
    for x in types {
        model.add_type(x);
    }
    for x in skillsets {
        model.add_skillset(x);
    }
};

//------------------------- Type -------------------------

Type: Vec<RlType> = {
    <v: TypeSingle*> => v,
    <v: TypeBlock> => v,
};

TypeSingle: RlType = "type" <x:Identifier> => {
    RlType::empty(x.name, Some(x.position))
};

TypeBlock: Vec<RlType> = "type" "{" <l:(<Identifier>)*> "}" => {
    let mut v = Vec::new();
    for x in l {
        v.push(RlType::empty(x.name, Some(x.position)))
    }
    v
};

//------------------------- Skillset -------------------------

Skillset: Skillset = "skillset" <x:Identifier> "{" <data:Data> <resources:Resource> <events:Event> <skills:Skill> "}" => {
    let mut skillset = Skillset::empty(x.name, Some(x.position));
    for x in data {
        skillset.add_data(x);
    }
    for x in resources {
        skillset.add_resource(x);
    }
    for x in events {
        skillset.add_event(x);
    }
    for x in skills {
        skillset.add_skill(x);
    }
    skillset
};

//------------------------- Data -------------------------

Data: Vec<Data> = {
    <v: DataSingle*> => v,
    <v: DataBlock> => v,
};

DataSingle: Data = "data" <x:Identifier> ":" <y:Identifier> => {
    let t = Reference::Unresolved(y.name, Some(y.position));
    Data::empty(x.name, t, Some(x.position))
};

DataBlock: Vec<Data> = "data" "{" <l:(<Identifier> ":" <Identifier>)*> "}" => {
    let mut v = Vec::new();
    for (x, y) in l {
        let t = Reference::Unresolved(y.name, Some(y.position));
        v.push(Data::empty(x.name, t, Some(x.position)));
    }
    v
};

//------------------------- Resource -------------------------

Resource: Vec<Resource> = {
    <v: ResourceSingle*> => v,
    <v: ResourceBlock> => v,
};

ResourceSingle: Resource = "resource" <x:ResourceDef> => {
    x
};

ResourceBlock: Vec<Resource> = "resource" "{" <l:ResourceDef*> "}" => {
    l
};

ResourceDef: Resource = <x:Identifier> "{" <s:StateDef> <i:InitialDef> <t:Transitions> "}" => {
    let mut resource = Resource::empty(x.name, Some(x.position));
    for x in s {
        resource.add_state(x);
    }
    resource.set_initial(i);
    resource.set_transitions(t);
    resource
};

StateDef: Vec<State> = "state" "{" <l:Identifier*> "}" => {
    let mut v = Vec::new();
    for x in l {
        v.push(State::empty(x.name, Some(x.position)));
    }
    v
};

InitialDef: Reference<StateId> = "initial" <i:Identifier> => {
    Reference::Unresolved(i.name, Some(i.position))
};

Transitions: Transitions = {
    "transition" "all" => Transitions::All,
    "transition" "{" <l:Transition*> "}" => Transitions::List(l),
};

Transition: Transition = <s:Identifier> "->" <d:Identifier> => {
    let src = Reference::Unresolved(s.name, Some(s.position));
    let dst = Reference::Unresolved(d.name, Some(d.position));
    Transition::new(src, dst)
};

//------------------------- Event -------------------------

Event: Vec<Event> = {
    <v: EventSingle*> => v,
    <v: EventBlock> => v,
};

EventSingle: Event = "event" <e:EventDef> => {
    e
};

EventBlock: Vec<Event> = "event" "{" <l:EventDef*> "}" => {
    l
};

EventDef: Event = <x:Identifier> "{" <g:Guard?> <l:Effects> "}" => {
    Event::empty(x.name, g, l, Some(x.position))
};

Guard: Expr = "guard" <e:Expr> => {
    e
};

//------------------------- Skill -------------------------

Skill: Vec<Skill> = {
    <v: SkillSingle*> => v,
    <v: SkillBlock> => v,
};

SkillSingle: Skill = "skill" <s:SkillDef> => {
    s
};

SkillBlock: Vec<Skill> = "skill" "{" <l:SkillDef*> "}" => {
    l
};

SkillDef: Skill = <x:Identifier> "{" <p:Precondition> "}" => {
    let mut skill = Skill::empty(x.name, Some(x.position));
    for x in p {
        skill.add_precondition(x);
    }
    skill
};

//------------------------- Precondition -------------------------

Precondition: Vec<Precondition> = {
    <v: PreconditionSingle*> => v,
    <v: PreconditionBlock> => v,
};

PreconditionSingle: Precondition = "precondition" <p:PreconditionDef> => {
    p
};

PreconditionBlock: Vec<Precondition> = "precondition" "{" <l:PreconditionDef*> "}" => {
    l
};

PreconditionDef: Precondition = <n:Identifier> ":" <e:Expr> => {
    Precondition::new(n.name, e, Some(n.position))
};


//------------------------- Effect -------------------------

Effects: Vec<Effect> = {
    <v: EffectSingle> => v,
    <v: EffectBlock> => v
};

EffectSingle: Vec<Effect> = "effect" <e:Effect> => {
    vec![e]
};

EffectBlock: Vec<Effect> = "effect" "{" <l:Effect*> "}" => {
    l
};

Effect: Effect = <r:Identifier> "->" <s:Identifier> => {
    let resource = Reference::Unresolved(r.name, Some(r.position));
    let state = Reference::Unresolved(s.name, Some(s.position));
    Effect::new(resource, state)
};

//------------------------- Expr -------------------------

Expr: Expr = ImpliesExpr;
ImpliesExpr: Expr = {
    <left:ImpliesExpr> "=>" <right:OrExpr> => {
        Expr::Implies(Box::new(left), Box::new(right))
    },
    OrExpr,
};
OrExpr: Expr = {
    <left:OrExpr> "or" <right:AndExpr> => {
        Expr::Or(Box::new(left), Box::new(right))
    },
    AndExpr,
};
AndExpr: Expr = {
    <left:AndExpr> "and" <right:NotExpr> => {
        Expr::And(Box::new(left), Box::new(right))
    },
    NotExpr,
};
NotExpr: Expr = {
    "not" <e: NotExpr> => {
        Expr::Not(Box::new(e))
    },
    Term,
};

Term: Expr = {
    "false" => Expr::False,
    "true" => Expr::True,
    <r:Identifier> "==" <s:Identifier> => {
        let resource = Reference::Unresolved(r.name, Some(r.position));
        let state = Reference::Unresolved(s.name, Some(s.position));
        Expr::ResourceEq(resource, state)
    },
    <r:Identifier> "!=" <s:Identifier> => {
        let resource = Reference::Unresolved(r.name, Some(r.position));
        let state = Reference::Unresolved(s.name, Some(s.position));
        Expr::ResourceNe(resource, state)
    },
    "(" <Expr> ")",
};

//------------------------- Lexer -------------------------

Identifier: Identifier = <l:@L> <s:r"[a-zA-Z_][a-zA-Z_0-9]*"> <r:@R> => {
    Identifier::new(lookup, s, l)
};